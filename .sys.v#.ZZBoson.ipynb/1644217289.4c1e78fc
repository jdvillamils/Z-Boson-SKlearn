{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "5462d3bf",
   "metadata": {},
   "source": [
    "# Basic Analysis of a BDT in ZZ production"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "15635181",
   "metadata": {},
   "source": [
    "This notebook uses the available Atlas Open Data http://opendata.atlas.cern, to study the ZZ diboson production http://opendata.atlas.cern/release/2020/documentation/physics/FL1.html.\n",
    "\n",
    "The purpose of this notebook is to study the basic  behaviour of a BDT applied in the ZZ diboson production, using SciKit learn. For that, we process and filter separately the events of signal and background of ZZ production. The, using the DecisionTreeClassifier tool, we can obtain a BDT value, which works as a criteria that allows to cut background information, to keep as much signal events as possible. \n",
    "This first look of the BDT behaviour is very useful in a future deep analysis. \n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 45,
   "id": "4667148d",
   "metadata": {},
   "outputs": [],
   "source": [
    "import uproot3\n",
    "import pandas as pd \n",
    "import ROOT\n",
    "from ROOT import TMath, TChain\n",
    "import time\n",
    "import numpy as np\n",
    "import root_pandas as rp\n",
    "import math\n",
    "import matplotlib.pyplot as plt \n",
    "from matplotlib.ticker import AutoMinorLocator \n",
    "\n",
    "#Local information file\n",
    "import infofile "
   ]
  },
  {
   "cell_type": "markdown",
   "id": "d34472b2",
   "metadata": {},
   "source": [
    "In this example, we just use one sample as signal, and 5 samples of background"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 46,
   "id": "66c1dc68",
   "metadata": {},
   "outputs": [],
   "source": [
    "treeS = TChain(\"mini\")\n",
    "treeS.Add(\"https://atlas-opendata.web.cern.ch/atlas-opendata/samples/2020/4lep/MC/mc_363490.llll.4lep.root\")\n",
    "totaleventsSignal=treeS.GetEntries()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 88,
   "id": "f8e3a19c",
   "metadata": {},
   "outputs": [],
   "source": [
    "treeb = TChain(\"mini\")\n",
    "treeb.Add(\"https://atlas-opendata.web.cern.ch/atlas-opendata/samples/2020/2lep/MC/mc_363491.lllv.2lep.root\")\n",
    "b1=treeb.GetEntries()\n",
    "treeb.Add(\"https://atlas-opendata.web.cern.ch/atlas-opendata/samples/2020/4lep/MC/mc_363491.lllv.4lep.root\")\n",
    "b2=treeb.GetEntries()\n",
    "treeb.Add(\"https://atlas-opendata.web.cern.ch/atlas-opendata/samples/2020/4lep/MC/mc_363358.WqqZll.4lep.root\")\n",
    "b3=treeb.GetEntries()\n",
    "treeb.Add(\"https://atlas-opendata.web.cern.ch/atlas-opendata/samples/2020/4lep/MC/mc_361106.Zee.4lep.root\")\n",
    "b4=treeb.GetEntries()\n",
    "treeb.Add(\"https://atlas-opendata.web.cern.ch/atlas-opendata/samples/2020/4lep/MC/mc_361107.Zmumu.4lep.root\")\n",
    "b5=treeb.GetEntries()\n",
    "#Save lenght info of each sample\n",
    "samplesBack=[b1,b2,b3,b4,b5]\n",
    "totaleventsBack=0\n",
    "for e in samplesBack:\n",
    "    totaleventsBack=totaleventsBack+e"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 54,
   "id": "2c53073a",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Running a total of  554279  events\n",
      "Initial events: 89464\n",
      "Final events: 20000\n",
      "Finished in 1 min 5 s\n"
     ]
    }
   ],
   "source": [
    "start = time.time()\n",
    "lepton1 = ROOT.TLorentzVector()\n",
    "lepton2 = ROOT.TLorentzVector()\n",
    "lepton3 = ROOT.TLorentzVector()\n",
    "lepton4 = ROOT.TLorentzVector()\n",
    "fourlep = ROOT.TLorentzVector()\n",
    "#Here, we define the Dataframe to store the variables.\n",
    "df1=pd.DataFrame(columns=('InvMassZ1', 'InvMassZ2', 'FourLeptonSystemPt', 'FourLeptonSystemMass','weight'))\n",
    "k=0\n",
    "kf=0\n",
    "lumi=10\n",
    "index1=0\n",
    "index2=0\n",
    "index3=0\n",
    "index4=0\n",
    "print(\"Running a total of \",totaleventsSignal,\" events\")\n",
    "#Star the analysis, cutting the events to keep just good events according AOD criteria\n",
    "for event in treeS:\n",
    "    k=k+1\n",
    "    goodlep=0\n",
    "    glindex=[]\n",
    "    lep_index=0\n",
    "    if(treeS.trigE or treeS.trigM):\n",
    "        if(treeS.lep_n>=4):\n",
    "            for j in range(treeS.lep_n):\n",
    "                #Looking leptons with pt>25 GeV\n",
    "                if((treeS.lep_pt[j]>25000.) and (treeS.lep_ptcone30[j]/treeS.lep_pt[j] < 0.15) and (treeS.lep_etcone20[j]/treeS.lep_pt[j] < 0.15)):\n",
    "                    #Electron in F zone\n",
    "                    if(treeS.lep_type[j]==11 and abs(treeS.lep_eta[j])<2.47 and (abs(treeS.lep_eta[j])<1.37 or abs(treeS.lep_eta[j])>1.52)):\n",
    "                        theta = 2*np.arctan(np.exp(-treeS.lep_eta[j]))\n",
    "                        if(treeS.lep_trackd0pvunbiased[j]/treeS.lep_tracksigd0pvunbiased[j] < 5 and abs(treeS.lep_z0[j]*np.sin(theta))<0.5):\n",
    "                            goodlep+=1\n",
    "                            glindex.append(j)\n",
    "                    #Good muons\n",
    "                    if(treeS.lep_type[j]==13 and abs(treeS.lep_eta[j]<2.5)):\n",
    "                        theta = 2*np.arctan(np.exp(-treeS.lep_eta[j]))\n",
    "                        if(treeS.lep_trackd0pvunbiased[j]/treeS.lep_tracksigd0pvunbiased[j] < 3 and abs(treeS.lep_z0[j]*np.sin(theta))<0.5):\n",
    "                            goodlep+=1\n",
    "                            glindex.append(j)\n",
    "            if(goodlep==4):\n",
    "                index1=glindex[0]\n",
    "                index2=glindex[1]\n",
    "                index3=glindex[2]\n",
    "                index4=glindex[3]\n",
    "                \n",
    "                lepton1.SetPtEtaPhiE(treeS.lep_pt[index1], treeS.lep_eta[index1], treeS.lep_phi[index1], treeS.lep_E[index1])\n",
    "                lepton2.SetPtEtaPhiE(treeS.lep_pt[index2], treeS.lep_eta[index2], treeS.lep_phi[index2], treeS.lep_E[index2])\n",
    "                lepton3.SetPtEtaPhiE(treeS.lep_pt[index3], treeS.lep_eta[index3], treeS.lep_phi[index3], treeS.lep_E[index3])\n",
    "                lepton4.SetPtEtaPhiE(treeS.lep_pt[index4], treeS.lep_eta[index4], treeS.lep_phi[index4], treeS.lep_E[index4])\n",
    "                deltaz1_1=0\n",
    "                deltaz2_1=0\n",
    "                deltaz1_2=0\n",
    "                deltaz2_2=0\n",
    "                deltaz1_3=0\n",
    "                deltaz2_3=0\n",
    "                invz1_1=0\n",
    "                invz2_1=0\n",
    "                invz1_2=0\n",
    "                invz2_2=0\n",
    "                invz1_3=0\n",
    "                invz2_3=0\n",
    "                #Here, we're looking for a pair of leptons, eeee, eemumu, mumumu\n",
    "                if((treeS.lep_charge[index1]+treeS.lep_charge[index2] + treeS.lep_charge[index3] + treeS.lep_charge[index4]) == 0):\n",
    "                    sumt=treeS.lep_type[index1]+treeS.lep_type[index2] + treeS.lep_type[index3] + treeS.lep_type[index4]\n",
    "                    if(sumt==44 or sumt==52):\n",
    "                        if(treeS.lep_type[index1]==treeS.lep_type[index2] and (treeS.lep_charge[index1]*treeS.lep_charge[index2]<0)):\n",
    "                            invz1_1=(lepton1+lepton2).Mag()/1000.\n",
    "                            invz2_1=(lepton3+lepton4).Mag()/1000.\n",
    "                            deltaz1_1=abs(invz1_1-91.18)\n",
    "                            deltaz2_1=abs(invz2_1-91.18)\n",
    "                        if(treeS.lep_type[index1]==treeS.lep_type[index3] and (treeS.lep_charge[index1]*treeS.lep_charge[index3]<0)):\n",
    "                            invz1_2=(lepton1+lepton3).Mag()/1000.\n",
    "                            invz2_2=(lepton2+lepton4).Mag()/1000.\n",
    "                            deltaz1_2=abs(invz1_2-91.18)\n",
    "                            deltaz2_2=abs(invz2_2-91.18)\n",
    "                        if(treeS.lep_type[index1]==treeS.lep_type[index4] and (treeS.lep_charge[index1]*treeS.lep_charge[index4]<0)):\n",
    "                            invz1_3=(lepton1+lepton4).Mag()/1000.\n",
    "                            invz2_3=(lepton2+lepton3).Mag()/1000.\n",
    "                            deltaz1_3=abs(invz1_3-91.18)\n",
    "                            deltaz2_3=abs(invz2_3-91.18)\n",
    "                        sumzz1=deltaz1_1+deltaz2_1\n",
    "                        sumzz2=deltaz1_2+deltaz2_2\n",
    "                        sumzz3=deltaz1_3+deltaz2_3\n",
    "                        \n",
    "                        if(sumzz1<sumzz2 and sumzz1<sumzz3):\n",
    "                            invz1min=invz1_1\n",
    "                            invz2min=invz2_1\n",
    "                            sumzz=sumzz1\n",
    "                        if(sumzz2<sumzz1 and sumzz2<sumzz3):\n",
    "                            invz1min=invz1_2\n",
    "                            invz2min=invz2_2\n",
    "                            sumzz=sumzz2\n",
    "                        if(sumzz3<sumzz1 and sumzz3<sumzz2):\n",
    "                            invz1min=invz1_3\n",
    "                            invz2min=invz2_3\n",
    "                            sumzz=sumzz3\n",
    "                            \n",
    "                    if(sumt==48):\n",
    "                        if(treeS.lep_type[index1]==treeS.lep_type[index2] and (treeS.lep_charge[index1]*treeS.lep_charge[index2]<0)):\n",
    "                            invz1=(lepton1+lepton2).Mag()/1000.\n",
    "                            invz2=(lepton3+lepton4).Mag()/1000.\n",
    "                            deltaz1=abs(invz1-91.18)\n",
    "                            deltaz2=abs(invz2-91.18)\n",
    "                        if(treeS.lep_type[index1]==treeS.lep_type[index3] and (treeS.lep_charge[index1]*treeS.lep_charge[index3]<0)):\n",
    "                            invz1=(lepton1+lepton3).Mag()/1000.\n",
    "                            invz2=(lepton2+lepton4).Mag()/1000.\n",
    "                            deltaz1=abs(invz1-91.18)\n",
    "                            deltaz2=abs(invz2-91.18)\n",
    "                        if(treeS.lep_type[index1]==treeS.lep_type[index4] and (treeS.lep_charge[index1]*treeS.lep_charge[index4]<0)):\n",
    "                            invz1=(lepton1+lepton4).Mag()/1000.\n",
    "                            invz2=(lepton2+lepton3).Mag()/1000.\n",
    "                            deltaz1=abs(invz1_3-91.18)\n",
    "                            deltaz2=abs(invz2_3-91.18)\n",
    "                        sumzz=deltaz1+deltaz2\n",
    "                        invz1min=invz1\n",
    "                        invz2min=invz2\n",
    "                    if(treeS.lep_pt[index1]>25000 or treeS.lep_pt[index2]>25000 or treeS.lep_pt[index3]>25000 or treeS.lep_pt[index4]>25000):\n",
    "                        if((sumt==44 or sumt==52 or sumt==48) and sumzz<50):\n",
    "                            fourlep=lepton1+lepton2+lepton3+lepton4\n",
    "                            fourleppt=fourlep.Pt()/1000.\n",
    "                            fourlepmass=fourlep.M()/1000.\n",
    "                            info = infofile.infos['llll']\n",
    "                            xsec_weight = (lumi*1000*info[\"xsec\"])/(info[\"sumw\"]*info[\"red_eff\"])\n",
    "                            weight=xsec_weight*treeS.mcWeight*treeS.scaleFactor_PILEUP*treeS.scaleFactor_ELE*treeS.scaleFactor_MUON*treeS.scaleFactor_LepTRIGGER\n",
    "                            #Save the good events in dataframe\n",
    "                            df1.loc[kf]=[invz1min,invz2min,fourleppt,fourlepmass,weight]\n",
    "                            kf+=1\n",
    "                            #We cut on 20000 good events to reduce compute times and keep approx the same size in signal and background\n",
    "                            if(kf==20000): break\n",
    "                           \n",
    "end = time.time()\n",
    "duration = end-start\n",
    "print('Initial events:', k)\n",
    "print('Final events:', kf)\n",
    "print(\"Finished in {} min {} s\".format(int(duration//60),int(duration%60)))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 55,
   "id": "82b02a80",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Running a total of  18998995  events\n",
      "Initial events: 3802777\n",
      "Final events: 20322\n",
      "Finished in 2 min 39 s\n"
     ]
    }
   ],
   "source": [
    "#Here we make a similar analysis that the one above, but \n",
    "start = time.time()\n",
    "lepton1 = ROOT.TLorentzVector()\n",
    "lepton2 = ROOT.TLorentzVector()\n",
    "lepton3 = ROOT.TLorentzVector()\n",
    "lepton4 = ROOT.TLorentzVector()\n",
    "fourlep = ROOT.TLorentzVector()\n",
    "df2=pd.DataFrame(columns=('InvMassZ1', 'InvMassZ2', 'FourLeptonSystemPt', 'FourLeptonSystemMass','weight'))\n",
    "k=0\n",
    "kf=0\n",
    "lumi=10\n",
    "index1=0\n",
    "index2=1\n",
    "index3=2\n",
    "index4=3\n",
    "print(\"Running a total of \",totaleventsBack,\" events\")\n",
    "for event in treeb:\n",
    "    k=k+1\n",
    "    if(treeb.lep_n>=4):\n",
    "            lepton1.SetPtEtaPhiE(treeb.lep_pt[index1], treeb.lep_eta[index1], treeb.lep_phi[index1], treeb.lep_E[index1])\n",
    "            lepton2.SetPtEtaPhiE(treeb.lep_pt[index2], treeb.lep_eta[index2], treeb.lep_phi[index2], treeb.lep_E[index2])\n",
    "            lepton3.SetPtEtaPhiE(treeb.lep_pt[index3], treeb.lep_eta[index3], treeb.lep_phi[index3], treeb.lep_E[index3])\n",
    "            lepton4.SetPtEtaPhiE(treeb.lep_pt[index4], treeb.lep_eta[index4], treeb.lep_phi[index4], treeb.lep_E[index4])\n",
    "            invz1min=(lepton1+lepton2).Mag()/1000.\n",
    "            invz2min=(lepton3+lepton4).Mag()/1000.\n",
    "            fourlep=lepton1+lepton2+lepton3+lepton4\n",
    "            fourleppt=fourlep.Pt()/1000.\n",
    "            fourlepmass=fourlep.M()/1000.\n",
    "            if(k<=samplesBack[0]):\n",
    "                sample='lllv'\n",
    "            if(k>samplesBack[0] and k<=samplesBack[1]):\n",
    "                sample='lllv'\n",
    "            if(k>samplesBack[1] and k<=samplesBack[2]):\n",
    "                sample='WqqZll'\n",
    "            if(k>samplesBack[2] and k<=samplesBack[3]):\n",
    "                sample='Zee'   \n",
    "            if(k>samplesBack[3] and k<=samplesBack[4]):\n",
    "                sample='Zmumu'\n",
    "            info = infofile.infos[sample]\n",
    "            xsec_weight = (lumi*1000*info[\"xsec\"])/(info[\"sumw\"]*info[\"red_eff\"])\n",
    "            weight=xsec_weight*treeb.mcWeight*treeb.scaleFactor_PILEUP*treeb.scaleFactor_ELE*treeb.scaleFactor_MUON*treeb.scaleFactor_LepTRIGGER\n",
    "            df2.loc[kf]=[invz1min,invz2min,fourleppt, fourlepmass,weight]\n",
    "            kf+=1\n",
    "                           \n",
    "end = time.time()\n",
    "duration = end-start\n",
    "print('Initial events:', k)\n",
    "print('Final events:', kf)\n",
    "print(\"Finished in {} min {} s\".format(int(duration//60),int(duration%60)))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 56,
   "id": "9d5c098e",
   "metadata": {},
   "outputs": [],
   "source": [
    "data={}\n",
    "samples=['Signal','Background']\n",
    "df_all=[df1,df2]\n",
    "for i in range(len(samples)):\n",
    "    frames=[]\n",
    "    data_all=pd.DataFrame()\n",
    "    data_all=data_all.append(df_all[i])\n",
    "    frames.append(data_all)\n",
    "    data[samples[i]]=pd.concat(frames)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 82,
   "id": "3e8d102a",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "{'Signal':         InvMassZ1  FourLeptonSystemPt  FourLeptonSystemMass\n",
       " 0        0.000000           65.123914            229.654312\n",
       " 1      116.196542           39.909485            296.506036\n",
       " 2       91.644210           49.478026            201.753759\n",
       " 3        0.000000           54.099883            243.221883\n",
       " 4        0.000000           20.353440            189.367043\n",
       " ...           ...                 ...                   ...\n",
       " 19995   90.532036           83.682386            604.463929\n",
       " 19996   87.975829            9.958951            180.038136\n",
       " 19997   93.494348           26.935306            395.504358\n",
       " 19998    0.000000          195.491878            420.974791\n",
       " 19999   89.538785           79.377170            212.905205\n",
       " \n",
       " [20000 rows x 3 columns],\n",
       " 'Background':         InvMassZ1  FourLeptonSystemPt  FourLeptonSystemMass\n",
       " 0      137.912358          109.515492            185.075693\n",
       " 1       91.877669           38.310877            180.281786\n",
       " 2      113.956847           42.585942            205.506440\n",
       " 3      289.375094           88.226439            345.788272\n",
       " 4       87.423385           96.707008            125.328573\n",
       " ...           ...                 ...                   ...\n",
       " 20317   67.093094           22.144804             98.064399\n",
       " 20318   94.897357           30.710859            143.918040\n",
       " 20319   90.469201           16.987045            134.392014\n",
       " 20320   93.553601           18.310934            137.094882\n",
       " 20321   99.020272            7.280900            116.186084\n",
       " \n",
       " [20322 rows x 3 columns]}"
      ]
     },
     "execution_count": 82,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "data_for_BDT = {} # define empty dictionary to hold dataframes that will be used to train the BDT\n",
    "BDT_inputs = ['InvMassZ1', 'FourLeptonSystemPt','FourLeptonSystemMass']#'InvMassZ2','FourLeptonSystemPt','FourLeptonSystemMass']# list of features for BDT\n",
    "for key in data: # loop over the different keys in the dictionary of dataframes\n",
    "    data_for_BDT[key] = data[key][BDT_inputs].copy()\n",
    "data_for_BDT"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "931c6ef4",
   "metadata": {},
   "source": [
    "Organising data"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 83,
   "id": "1d6e378c",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[0. 0. 0. ... 1. 1. 1.]\n"
     ]
    }
   ],
   "source": [
    "all_MC = [] # define empty list that will contain all features for the MC\n",
    "for key in data: # loop over the different keys in the dictionary of dataframes\n",
    "    if key!='data': # only MC should pass this\n",
    "        all_MC.append(data_for_BDT[key]) # append the MC dataframe to the list containing all MC features\n",
    "X = np.concatenate(all_MC) # concatenate the list of MC dataframes into a single 2D array of features, called X\n",
    "#print(X)\n",
    "all_y = [] # define empty list that will contain labels whether an event in signal or background\n",
    "for key in data: # loop over the different keys in the dictionary of dataframes\n",
    "    if key!='Signal' and key!='data': # only background MC should pass this\n",
    "        all_y.append(np.zeros(data_for_BDT[key].shape[0])) # background events are labelled with 0\n",
    "all_y.append(np.ones(data_for_BDT['Signal'].shape[0])) # signal events are labelled with 1\n",
    "y = np.concatenate(all_y) # concatenate the list of lables into a single 1D array of labels, called y\n",
    "print(y)\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "aac37527",
   "metadata": {},
   "source": [
    "Split for training and testing"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 84,
   "id": "f1f43892",
   "metadata": {},
   "outputs": [],
   "source": [
    "from sklearn.model_selection import train_test_split\n",
    "\n",
    "# make train and test sets\n",
    "X_train,X_test, y_train,y_test = train_test_split(X, y, \n",
    "                                                  test_size=0.33, \n",
    "                                                  random_state=492 )"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 85,
   "id": "3a9daf57",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Time taken to fit BDT: 0.4s\n",
      "AdaBoostClassifier(algorithm='SAMME',\n",
      "                   base_estimator=DecisionTreeClassifier(max_depth=2),\n",
      "                   learning_rate=0.5, n_estimators=12)\n"
     ]
    }
   ],
   "source": [
    "from sklearn.tree import DecisionTreeClassifier\n",
    "from sklearn.ensemble import AdaBoostClassifier\n",
    "\n",
    "dt = DecisionTreeClassifier(max_depth=2) # maximum depth of the tree\n",
    "bdt = AdaBoostClassifier(dt,\n",
    "                        algorithm='SAMME', # SAMME discrete boosting algorithm\n",
    "                        n_estimators=12, # max number of estimators at which boosting is terminated\n",
    "                        learning_rate=0.5) # shrinks the contribution of each classifier by learning_rate\n",
    "\n",
    "start = time.time() # time at start of BDT fit\n",
    "bdt.fit(X_train, y_train) # fit BDT to training set\n",
    "elapsed = time.time() - start # time after fitting BDT\n",
    "print(\"Time taken to fit BDT: \"+str(round(elapsed,1))+\"s\") # print total time taken to fit BDT\n",
    "print(bdt)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 86,
   "id": "9ea16507",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "              precision    recall  f1-score   support\n",
      "\n",
      "  background       0.84      0.96      0.90      6696\n",
      "      signal       0.95      0.82      0.88      6611\n",
      "\n",
      "    accuracy                           0.89     13307\n",
      "   macro avg       0.90      0.89      0.89     13307\n",
      "weighted avg       0.90      0.89      0.89     13307\n",
      "\n",
      "Area under ROC curve for test data: 0.9633\n"
     ]
    }
   ],
   "source": [
    "from sklearn.metrics import classification_report, roc_auc_score\n",
    "y_predicted = bdt.predict(X_test) # get predicted y for test set\n",
    "print (classification_report(y_test, y_predicted,\n",
    "                            target_names=[\"background\", \"signal\"]))\n",
    "print (\"Area under ROC curve for test data: %.4f\"%(roc_auc_score(y_test,\n",
    "                                                    bdt.decision_function(X_test))) )"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 87,
   "id": "02665fcf",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "iVBORw0KGgoAAAANSUhEUgAAAYIAAAEGCAYAAABo25JHAAAAOXRFWHRTb2Z0d2FyZQBNYXRwbG90bGliIHZlcnNpb24zLjQuMywgaHR0cHM6Ly9tYXRwbG90bGliLm9yZy/MnkTPAAAACXBIWXMAAAsTAAALEwEAmpwYAAAlQ0lEQVR4nO3dfXRV9Z3v8fcXjKVWrVWoJoAJ3oVVCyIkoq1UqE8DlqB0rKNLq/aBgMrqdKZ6q84sCe1MZ6bjdN0+TKuhdaq9XEurrRIGZ2pbLKVqSxJ5UrSDDmgIVaQOQlVa9Hv/2DtwEk6SnWTvc3b2/rzW2ivn7Iff+Z59knzPb/8etrk7IiKSX8PKHYCIiJSXEoGISM4pEYiI5JwSgYhIzikRiIjk3GHlDqC/Ro4c6TU1NeUOQ0RkSGltbX3F3UcV2zbkEkFNTQ0tLS3lDkNEZEgxs209bdOlIRGRnFMiEBHJOSUCEZGcG3JtBCIyNPzpT3+ivb2dN998s9yh5MqIESMYM2YMFRUVkY9RIhCRRLS3t3PUUUdRU1ODmZU7nFxwd3bt2kV7ezvjxo2LfJwuDYlIIt58802OO+44JYESMjOOO+64ftfClAhEJDFKAqU3kHOuRCAiknNKBCJSGjU1YBbfEmGGga1btzJhwoRBhf3oo48ye/bsQZWRlJqaGl555ZVBl5OvxuKaGtjW4+C6ZFRXw9atpX1NkTTatg3ivBHWELjs5O64O8OGpfs7d7qji1vnL2Ipl1InHhHpYv/+/Vx77bWcfvrpXHbZZbz++ut84Qtf4Mwzz2TChAk0NDTQeafGLVu2cMEFFzBp0iSmTJnCc88916WstWvXMnnyZJ5//nl27tzJhRdeyJQpU5g/fz7V1dW88sorbN26lVNPPZUbbriBKVOm8OKLL3LzzTczYcIEJk6cyLJly4BDaxoLFy7ku9/9LhB801+0aBFTpkxh4sSJPPPMMwDs2rWLiy66iMmTJzN//nziusNkvhKBiOTOs88+S0NDAxs2bODoo4/mm9/8JgsXLmTt2rVs2rSJN954gxUrVgBw1VVXceONN7J+/Xoee+wxKisrD5Tz2GOPsWDBAh566CFOOukkFi9ezHnnnUdbWxtz587lhRde6PKa11xzDU8++SQtLS2sW7eO9evX89Of/pSbb76ZHTt29Bn3yJEjaWtr4/rrr+eOO+4AYPHixUybNo0nn3ySOXPmdHnNwVAiEJFMGzt2LOeccw4AV199NWvWrGHVqlWcddZZTJw4kZ///Oc89dRT7Nmzh+3btzN37lwgGJh1xBFHALB582YaGhpobm7mxBNPBGDNmjVcccUVAMycOZP3vOc9B16zurqas88++8B+V155JcOHD+f4449n+vTprF27ts+4P/rRjwJQW1vL1vDy8urVq7n66qsB+MhHPtLlNQdDiUBEMq17d0oz44YbbuD+++9n48aNzJs3jzfffLPXyyyVlZWMGDGCJ5988sC63vZ/17ve1ed+hx12GG+//faB5937/r/jHe8AYPjw4ezfv7/H9xMHJQIRybQXXniBxx9/HID77ruPadOmAcGll71793L//fcDcPTRRzNmzBgefPBBAPbt28frr78OwDHHHMO///u/c9ttt/Hoo48CMG3aNH7wgx8A8JOf/IRXX3216Oufe+65LFu2jLfeeoudO3eyevVqpk6dSnV1NU8//TT79u1j9+7d/OxnP+vzvZx77rksXboUgIcffrjH1+yvfPUaEpHyqa6Ot6dPdXWk3U499VTuuece5s+fz/jx47n++ut59dVXmThxIjU1NZx55pkH9v3e977H/Pnzuf3226moqOCHP/zhgW3HH388zc3NzJo1i7vvvptFixZx5ZVXsmzZMqZPn05lZSVHHXUUe/fu7fL6c+fO5fHHH2fSpEmYGV/+8pc54YQTALj88ss5/fTTGT9+PJMnT+7zvXS+5pQpU5g+ffqBy1SDZXG1OpdKXV2dD/jGNGbxdl9L62uKpMDmzZs59dRTyx1GYvbt28fw4cM57LDDePzxx7n++utZt25ducMCip97M2t197pi+6tGICIyAC+88AKXX345b7/9NocffjhLliwpd0gDpkQgIjIA48eP79J4PJQl1lhsZiPM7Ddmtt7MnjKzxUX2MTP7mpltMbMNZjYlqXhERKS4JGsE+4Dz3H2vmVUAa8zsYXd/omCfWcD4cDkL+Fb4U0RESiSxGoEHOpvPK8Kle6vpJcC94b5PAMeYWSUiIlIyiY4jMLPhZrYOeBl4xN1/3W2X0cCLBc/bw3Xdy2kwsxYza9m5c2di8YqI5FGiicDd33L3M4AxwFQz6z4fbLFOxYf0tXT3Jnevc/e6UaNGJRCpiJRCQ0PXmaQ7OqC5ueu6pqZg38J19fXBuvr6rusH4tOf/jRPP/10PG+owJFHHhl7maVSkl5D7v4/ZvYoMBPYVLCpHRhb8HwM0FGKmESktGprobX14D/6TlVVxYfaFFvX3Dz4OL797W8PvpCMSbLX0CgzOyZ8/E7gAuCZbrstB64Jew+dDex2976n5RORIaetLd7yuieUYv7whz/wkY98hEmTJjFhwgSWLVvGjBkz6ByU+p3vfIeTTz6ZGTNmMG/ePBYuXAjAddddx2c+8xk++MEPctJJJx2YhmLv3r2cf/75B6aHfuihh+J9U2WS5KWhSmCVmW0A1hK0EawwswVmtiDcZyXwPLAFWALckGA8IpIh8+f3vc9//Md/UFVVxfr169m0aRMzZ848sK2jo4MvfvGLPPHEEzzyyCMH5vzvtGPHDtasWcOKFSu45ZZbgGBG0h//+Me0tbWxatUqPve5z8V2T4BySuzSkLtvAA6ZPMPd7yx47MCNScUgIulRWYb+gBMnTuSmm27i85//PLNnz+ZDH/rQgW2/+c1vmD59OsceeywAH/vYx/jtb397YPull17KsGHDOO2003jppZeAYCbR2267jdWrVzNs2DC2b9/OSy+9dGDuoKFKI4tFpCQ6ytD6d/LJJ9Pa2srKlSu59dZbueiiiw5s6+ubfOc00IX7Ll26lJ07d9La2kpFRQU1NTWHTB89FGkaahEpicbGeMtbvrzvfTo6OjjiiCO4+uqruemmm2graKiYOnUqv/jFL3j11VfZv38/DzzwQJ/l7d69m/e+971UVFSwatUqtmXkVrRKBCJSEosXd+362doaLIXrOpNFVdXBdbW1wbruXU871/dm48aNTJ06lTPOOIO///u/52//9m8PbBs9ejS33XYbZ511FhdccAGnnXYa7373u3st76qrrqKlpYW6ujqWLl3KKaecMsCzkS6ahjppmoZacmooTEO9d+9ejjzySPbv38/cuXP55Cc/eeBWlUNZf6ehVo1ARHKrsbGRM844gwkTJjBu3DguvfTScodUFmosFpHcuuOOO8odQiqoRiAiiRlql56zYCDnXIlARBIxYsQIdu3apWRQQu7Orl27GDFiRL+O06UhEUnEmDFjaG9vRzMGl9aIESMYM2ZMv45RIhCRRFRUVDBu3LhyhyER6NKQiEjOKRGIiOScEoGISM4pEYiI5JwSgYhIzikRiIjknBKBiEjOKRGIiOSc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\n",
      "text/plain": [
       "<Figure size 432x288 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    },
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 432x288 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "# we first plot the Neural Network output\n",
    "signal_decisions = bdt.decision_function(X[y>0.5]).ravel() # get probabilities on signal\n",
    "background_decisions = bdt.decision_function(X[y<0.5]).ravel() # get decisions on background\n",
    "\n",
    "plt.hist(background_decisions, color='red', label='background', \n",
    "         histtype='step', # lineplot that's unfilled\n",
    "         density=True ) # normalize to form a probability density\n",
    "plt.hist(signal_decisions, color='blue', label='signal', \n",
    "         histtype='step', # lineplot that's unfilled\n",
    "         density=True, # normalize to form a probability density\n",
    "         linestyle='--' ) # dashed line\n",
    "plt.xlabel('BDT output') # add x-axis label\n",
    "plt.ylabel('Arbitrary units') # add y-axis label\n",
    "plt.legend() # add legend\n",
    "\n",
    "\n",
    "# we then plot the ROC\n",
    "plt.figure() #make new figure \n",
    "\n",
    "from sklearn.metrics import roc_curve, auc\n",
    "\n",
    "decisions = bdt.decision_function(X_test).ravel() # get probabilities on test set\n",
    "\n",
    "# Compute ROC curve and area under the curve\n",
    "fpr, tpr, _ = roc_curve(y_test, # actual\n",
    "                        decisions ) # predicted\n",
    "\n",
    "# Compute area under the curve for training set\n",
    "roc_auc = auc(fpr, # false positive rate \n",
    "              tpr) # true positive rate\n",
    "\n",
    "plt.plot(fpr, tpr, label='ROC (area = %0.2f)'%(roc_auc)) # plot test ROC curve\n",
    "plt.plot([0, 1], # x from 0 to 1\n",
    "         [0, 1], # y from 0 to 1\n",
    "         '--', # dashed line\n",
    "         color='grey', label='Luck')\n",
    "\n",
    "plt.xlabel('False Positive Rate') #x-axis label\n",
    "plt.ylabel('True Positive Rate') # y-axis label\n",
    "plt.title('Receiver operating characteristic (ROC) curve') # title\n",
    "plt.legend() # add legend\n",
    "plt.grid() # add grid"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.9.6"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
