{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "5462d3bf",
   "metadata": {},
   "source": [
    "# Basic Analysis of a BDT in ZZ production"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "d311bb07",
   "metadata": {},
   "source": [
    "This notebook uses the available Atlas Open Data http://opendata.atlas.cern, to study the ZZ diboson production http://opendata.atlas.cern/release/2020/documentation/physics/FL1.html.\n",
    "\n",
    "The purpose of this notebook is to study the basic  behaviour of a BDT applied in the ZZ diboson production, using SciKit learn. For that, we process and filter separately the events of signal and background of ZZ production. The, using the DecisionTreeClassifier tool, we can obtain a BDT value, which works as a criteria that allows to cut background information, to keep as much signal events as possible. \n",
    "This first look of the BDT behaviour is very useful in a future deep analysis. \n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 45,
   "id": "4667148d",
   "metadata": {},
   "outputs": [],
   "source": [
    "import uproot3\n",
    "import pandas as pd \n",
    "import ROOT\n",
    "from ROOT import TMath, TChain\n",
    "import time\n",
    "import numpy as np\n",
    "import root_pandas as rp\n",
    "import math\n",
    "import matplotlib.pyplot as plt \n",
    "from matplotlib.ticker import AutoMinorLocator \n",
    "\n",
    "#Local information file\n",
    "import infofile "
   ]
  },
  {
   "cell_type": "markdown",
   "id": "d34472b2",
   "metadata": {},
   "source": [
    "In this example, we just use one sample as signal, and 5 samples of background"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 46,
   "id": "66c1dc68",
   "metadata": {},
   "outputs": [],
   "source": [
    "treeS = TChain(\"mini\")\n",
    "treeS.Add(\"https://atlas-opendata.web.cern.ch/atlas-opendata/samples/2020/4lep/MC/mc_363490.llll.4lep.root\")\n",
    "totaleventsSignal=treeS.GetEntries()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 88,
   "id": "f8e3a19c",
   "metadata": {},
   "outputs": [],
   "source": [
    "treeb = TChain(\"mini\")\n",
    "treeb.Add(\"https://atlas-opendata.web.cern.ch/atlas-opendata/samples/2020/2lep/MC/mc_363491.lllv.2lep.root\")\n",
    "b1=treeb.GetEntries()\n",
    "treeb.Add(\"https://atlas-opendata.web.cern.ch/atlas-opendata/samples/2020/4lep/MC/mc_363491.lllv.4lep.root\")\n",
    "b2=treeb.GetEntries()\n",
    "treeb.Add(\"https://atlas-opendata.web.cern.ch/atlas-opendata/samples/2020/4lep/MC/mc_363358.WqqZll.4lep.root\")\n",
    "b3=treeb.GetEntries()\n",
    "treeb.Add(\"https://atlas-opendata.web.cern.ch/atlas-opendata/samples/2020/4lep/MC/mc_361106.Zee.4lep.root\")\n",
    "b4=treeb.GetEntries()\n",
    "treeb.Add(\"https://atlas-opendata.web.cern.ch/atlas-opendata/samples/2020/4lep/MC/mc_361107.Zmumu.4lep.root\")\n",
    "b5=treeb.GetEntries()\n",
    "#Save lenght info of each sample\n",
    "samplesBack=[b1,b2,b3,b4,b5]\n",
    "totaleventsBack=0\n",
    "for e in samplesBack:\n",
    "    totaleventsBack=totaleventsBack+e"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 54,
   "id": "2c53073a",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Running a total of  554279  events\n",
      "Initial events: 89464\n",
      "Final events: 20000\n",
      "Finished in 1 min 5 s\n"
     ]
    }
   ],
   "source": [
    "start = time.time()\n",
    "lepton1 = ROOT.TLorentzVector()\n",
    "lepton2 = ROOT.TLorentzVector()\n",
    "lepton3 = ROOT.TLorentzVector()\n",
    "lepton4 = ROOT.TLorentzVector()\n",
    "fourlep = ROOT.TLorentzVector()\n",
    "#Here, we define the Dataframe to store the variables.\n",
    "df1=pd.DataFrame(columns=('InvMassZ1', 'InvMassZ2', 'FourLeptonSystemPt', 'FourLeptonSystemMass','weight'))\n",
    "k=0\n",
    "kf=0\n",
    "lumi=10\n",
    "index1=0\n",
    "index2=0\n",
    "index3=0\n",
    "index4=0\n",
    "print(\"Running a total of \",totaleventsSignal,\" events\")\n",
    "#Star the analysis, cutting the events to keep just good events according AOD criteria\n",
    "for event in treeS:\n",
    "    k=k+1\n",
    "    goodlep=0\n",
    "    glindex=[]\n",
    "    lep_index=0\n",
    "    if(treeS.trigE or treeS.trigM):\n",
    "        if(treeS.lep_n>=4):\n",
    "            for j in range(treeS.lep_n):\n",
    "                #Looking leptons with pt>25 GeV\n",
    "                if((treeS.lep_pt[j]>25000.) and (treeS.lep_ptcone30[j]/treeS.lep_pt[j] < 0.15) and (treeS.lep_etcone20[j]/treeS.lep_pt[j] < 0.15)):\n",
    "                    #Electron in F zone\n",
    "                    if(treeS.lep_type[j]==11 and abs(treeS.lep_eta[j])<2.47 and (abs(treeS.lep_eta[j])<1.37 or abs(treeS.lep_eta[j])>1.52)):\n",
    "                        theta = 2*np.arctan(np.exp(-treeS.lep_eta[j]))\n",
    "                        if(treeS.lep_trackd0pvunbiased[j]/treeS.lep_tracksigd0pvunbiased[j] < 5 and abs(treeS.lep_z0[j]*np.sin(theta))<0.5):\n",
    "                            goodlep+=1\n",
    "                            glindex.append(j)\n",
    "                    #Good muons\n",
    "                    if(treeS.lep_type[j]==13 and abs(treeS.lep_eta[j]<2.5)):\n",
    "                        theta = 2*np.arctan(np.exp(-treeS.lep_eta[j]))\n",
    "                        if(treeS.lep_trackd0pvunbiased[j]/treeS.lep_tracksigd0pvunbiased[j] < 3 and abs(treeS.lep_z0[j]*np.sin(theta))<0.5):\n",
    "                            goodlep+=1\n",
    "                            glindex.append(j)\n",
    "            if(goodlep==4):\n",
    "                index1=glindex[0]\n",
    "                index2=glindex[1]\n",
    "                index3=glindex[2]\n",
    "                index4=glindex[3]\n",
    "                \n",
    "                lepton1.SetPtEtaPhiE(treeS.lep_pt[index1], treeS.lep_eta[index1], treeS.lep_phi[index1], treeS.lep_E[index1])\n",
    "                lepton2.SetPtEtaPhiE(treeS.lep_pt[index2], treeS.lep_eta[index2], treeS.lep_phi[index2], treeS.lep_E[index2])\n",
    "                lepton3.SetPtEtaPhiE(treeS.lep_pt[index3], treeS.lep_eta[index3], treeS.lep_phi[index3], treeS.lep_E[index3])\n",
    "                lepton4.SetPtEtaPhiE(treeS.lep_pt[index4], treeS.lep_eta[index4], treeS.lep_phi[index4], treeS.lep_E[index4])\n",
    "                deltaz1_1=0\n",
    "                deltaz2_1=0\n",
    "                deltaz1_2=0\n",
    "                deltaz2_2=0\n",
    "                deltaz1_3=0\n",
    "                deltaz2_3=0\n",
    "                invz1_1=0\n",
    "                invz2_1=0\n",
    "                invz1_2=0\n",
    "                invz2_2=0\n",
    "                invz1_3=0\n",
    "                invz2_3=0\n",
    "                #Here, we're looking for a pair of leptons, eeee, eemumu, mumumu\n",
    "                if((treeS.lep_charge[index1]+treeS.lep_charge[index2] + treeS.lep_charge[index3] + treeS.lep_charge[index4]) == 0):\n",
    "                    sumt=treeS.lep_type[index1]+treeS.lep_type[index2] + treeS.lep_type[index3] + treeS.lep_type[index4]\n",
    "                    if(sumt==44 or sumt==52):\n",
    "                        if(treeS.lep_type[index1]==treeS.lep_type[index2] and (treeS.lep_charge[index1]*treeS.lep_charge[index2]<0)):\n",
    "                            invz1_1=(lepton1+lepton2).Mag()/1000.\n",
    "                            invz2_1=(lepton3+lepton4).Mag()/1000.\n",
    "                            deltaz1_1=abs(invz1_1-91.18)\n",
    "                            deltaz2_1=abs(invz2_1-91.18)\n",
    "                        if(treeS.lep_type[index1]==treeS.lep_type[index3] and (treeS.lep_charge[index1]*treeS.lep_charge[index3]<0)):\n",
    "                            invz1_2=(lepton1+lepton3).Mag()/1000.\n",
    "                            invz2_2=(lepton2+lepton4).Mag()/1000.\n",
    "                            deltaz1_2=abs(invz1_2-91.18)\n",
    "                            deltaz2_2=abs(invz2_2-91.18)\n",
    "                        if(treeS.lep_type[index1]==treeS.lep_type[index4] and (treeS.lep_charge[index1]*treeS.lep_charge[index4]<0)):\n",
    "                            invz1_3=(lepton1+lepton4).Mag()/1000.\n",
    "                            invz2_3=(lepton2+lepton3).Mag()/1000.\n",
    "                            deltaz1_3=abs(invz1_3-91.18)\n",
    "                            deltaz2_3=abs(invz2_3-91.18)\n",
    "                        sumzz1=deltaz1_1+deltaz2_1\n",
    "                        sumzz2=deltaz1_2+deltaz2_2\n",
    "                        sumzz3=deltaz1_3+deltaz2_3\n",
    "                        \n",
    "                        if(sumzz1<sumzz2 and sumzz1<sumzz3):\n",
    "                            invz1min=invz1_1\n",
    "                            invz2min=invz2_1\n",
    "                            sumzz=sumzz1\n",
    "                        if(sumzz2<sumzz1 and sumzz2<sumzz3):\n",
    "                            invz1min=invz1_2\n",
    "                            invz2min=invz2_2\n",
    "                            sumzz=sumzz2\n",
    "                        if(sumzz3<sumzz1 and sumzz3<sumzz2):\n",
    "                            invz1min=invz1_3\n",
    "                            invz2min=invz2_3\n",
    "                            sumzz=sumzz3\n",
    "                            \n",
    "                    if(sumt==48):\n",
    "                        if(treeS.lep_type[index1]==treeS.lep_type[index2] and (treeS.lep_charge[index1]*treeS.lep_charge[index2]<0)):\n",
    "                            invz1=(lepton1+lepton2).Mag()/1000.\n",
    "                            invz2=(lepton3+lepton4).Mag()/1000.\n",
    "                            deltaz1=abs(invz1-91.18)\n",
    "                            deltaz2=abs(invz2-91.18)\n",
    "                        if(treeS.lep_type[index1]==treeS.lep_type[index3] and (treeS.lep_charge[index1]*treeS.lep_charge[index3]<0)):\n",
    "                            invz1=(lepton1+lepton3).Mag()/1000.\n",
    "                            invz2=(lepton2+lepton4).Mag()/1000.\n",
    "                            deltaz1=abs(invz1-91.18)\n",
    "                            deltaz2=abs(invz2-91.18)\n",
    "                        if(treeS.lep_type[index1]==treeS.lep_type[index4] and (treeS.lep_charge[index1]*treeS.lep_charge[index4]<0)):\n",
    "                            invz1=(lepton1+lepton4).Mag()/1000.\n",
    "                            invz2=(lepton2+lepton3).Mag()/1000.\n",
    "                            deltaz1=abs(invz1_3-91.18)\n",
    "                            deltaz2=abs(invz2_3-91.18)\n",
    "                        sumzz=deltaz1+deltaz2\n",
    "                        invz1min=invz1\n",
    "                        invz2min=invz2\n",
    "                    if(treeS.lep_pt[index1]>25000 or treeS.lep_pt[index2]>25000 or treeS.lep_pt[index3]>25000 or treeS.lep_pt[index4]>25000):\n",
    "                        if((sumt==44 or sumt==52 or sumt==48) and sumzz<50):\n",
    "                            fourlep=lepton1+lepton2+lepton3+lepton4\n",
    "                            fourleppt=fourlep.Pt()/1000.\n",
    "                            fourlepmass=fourlep.M()/1000.\n",
    "                            info = infofile.infos['llll']\n",
    "                            xsec_weight = (lumi*1000*info[\"xsec\"])/(info[\"sumw\"]*info[\"red_eff\"])\n",
    "                            weight=xsec_weight*treeS.mcWeight*treeS.scaleFactor_PILEUP*treeS.scaleFactor_ELE*treeS.scaleFactor_MUON*treeS.scaleFactor_LepTRIGGER\n",
    "                            #Save the good events in dataframe\n",
    "                            df1.loc[kf]=[invz1min,invz2min,fourleppt,fourlepmass,weight]\n",
    "                            kf+=1\n",
    "                            #We cut on 20000 good events to reduce compute times and keep approx the same size in signal and background\n",
    "                            if(kf==20000): break\n",
    "                           \n",
    "end = time.time()\n",
    "duration = end-start\n",
    "print('Initial events:', k)\n",
    "print('Final events:', kf)\n",
    "print(\"Finished in {} min {} s\".format(int(duration//60),int(duration%60)))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 55,
   "id": "82b02a80",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Running a total of  18998995  events\n",
      "Initial events: 3802777\n",
      "Final events: 20322\n",
      "Finished in 2 min 39 s\n"
     ]
    }
   ],
   "source": [
    "#Here we make a similar analysis that the one above, but the only selection criteria is keeping four leptons\n",
    "#This because we don't want to clean background events because that may cause a false trainig.\n",
    "start = time.time()\n",
    "lepton1 = ROOT.TLorentzVector()\n",
    "lepton2 = ROOT.TLorentzVector()\n",
    "lepton3 = ROOT.TLorentzVector()\n",
    "lepton4 = ROOT.TLorentzVector()\n",
    "fourlep = ROOT.TLorentzVector()\n",
    "df2=pd.DataFrame(columns=('InvMassZ1', 'InvMassZ2', 'FourLeptonSystemPt', 'FourLeptonSystemMass','weight'))\n",
    "k=0\n",
    "kf=0\n",
    "lumi=10\n",
    "index1=0\n",
    "index2=1\n",
    "index3=2\n",
    "index4=3\n",
    "print(\"Running a total of \",totaleventsBack,\" events\")\n",
    "for event in treeb:\n",
    "    k=k+1\n",
    "    if(treeb.lep_n>=4):\n",
    "            lepton1.SetPtEtaPhiE(treeb.lep_pt[index1], treeb.lep_eta[index1], treeb.lep_phi[index1], treeb.lep_E[index1])\n",
    "            lepton2.SetPtEtaPhiE(treeb.lep_pt[index2], treeb.lep_eta[index2], treeb.lep_phi[index2], treeb.lep_E[index2])\n",
    "            lepton3.SetPtEtaPhiE(treeb.lep_pt[index3], treeb.lep_eta[index3], treeb.lep_phi[index3], treeb.lep_E[index3])\n",
    "            lepton4.SetPtEtaPhiE(treeb.lep_pt[index4], treeb.lep_eta[index4], treeb.lep_phi[index4], treeb.lep_E[index4])\n",
    "            invz1min=(lepton1+lepton2).Mag()/1000.\n",
    "            invz2min=(lepton3+lepton4).Mag()/1000.\n",
    "            fourlep=lepton1+lepton2+lepton3+lepton4\n",
    "            fourleppt=fourlep.Pt()/1000.\n",
    "            fourlepmass=fourlep.M()/1000.\n",
    "            if(k<=samplesBack[0]):\n",
    "                sample='lllv'\n",
    "            if(k>samplesBack[0] and k<=samplesBack[1]):\n",
    "                sample='lllv'\n",
    "            if(k>samplesBack[1] and k<=samplesBack[2]):\n",
    "                sample='WqqZll'\n",
    "            if(k>samplesBack[2] and k<=samplesBack[3]):\n",
    "                sample='Zee'   \n",
    "            if(k>samplesBack[3] and k<=samplesBack[4]):\n",
    "                sample='Zmumu'\n",
    "            info = infofile.infos[sample]\n",
    "            xsec_weight = (lumi*1000*info[\"xsec\"])/(info[\"sumw\"]*info[\"red_eff\"])\n",
    "            weight=xsec_weight*treeb.mcWeight*treeb.scaleFactor_PILEUP*treeb.scaleFactor_ELE*treeb.scaleFactor_MUON*treeb.scaleFactor_LepTRIGGER\n",
    "            df2.loc[kf]=[invz1min,invz2min,fourleppt, fourlepmass,weight]\n",
    "            kf+=1\n",
    "                           \n",
    "end = time.time()\n",
    "duration = end-start\n",
    "print('Initial events:', k)\n",
    "print('Final events:', kf)\n",
    "print(\"Finished in {} min {} s\".format(int(duration//60),int(duration%60)))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 56,
   "id": "9d5c098e",
   "metadata": {},
   "outputs": [],
   "source": [
    "#Concatenate all information into one dataframe\n",
    "data={}\n",
    "samples=['Signal','Background']\n",
    "df_all=[df1,df2]\n",
    "for i in range(len(samples)):\n",
    "    frames=[]\n",
    "    data_all=pd.DataFrame()\n",
    "    data_all=data_all.append(df_all[i])\n",
    "    frames.append(data_all)\n",
    "    data[samples[i]]=pd.concat(frames)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "cbd1d8be",
   "metadata": {},
   "source": [
    "Choose the variables for the BDT and organise the data"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 89,
   "id": "3e8d102a",
   "metadata": {},
   "outputs": [],
   "source": [
    "data_for_BDT = {}\n",
    "BDT_inputs = ['InvMassZ1', 'FourLeptonSystemPt','FourLeptonSystemMass']#'InvMassZ2','FourLeptonSystemPt','FourLeptonSystemMass']# list of features for BDT\n",
    "for key in data:\n",
    "    data_for_BDT[key] = data[key][BDT_inputs].copy()\n",
    "    \n",
    "all_MC = [] #List that will contain all simulated data, signal and background.\n",
    "for key in data:\n",
    "    if key!='data': \n",
    "        all_MC.append(data_for_BDT[key])\n",
    "X = np.concatenate(all_MC)\n",
    "\n",
    "all_y = [] # List to store information of signal and background as zeros and ones\n",
    "for key in data:\n",
    "    if key!='Signal' and key!='data': \n",
    "        all_y.append(np.zeros(data_for_BDT[key].shape[0])) # background events are labelled with 0\n",
    "all_y.append(np.ones(data_for_BDT['Signal'].shape[0])) # signal events are labelled with 1\n",
    "y = np.concatenate(all_y) \n",
    "print(y)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "aac37527",
   "metadata": {},
   "source": [
    "When training a learning program, it is necessary to use just a fraction of the information for the training, usually the propotions of the samples used for testing and training vary according to 50%-50% or 67%-33%, depending the specific case. These two samples are independet and should not be mixed or used for test if it corresponds to training or viceversa.  \n",
    "\n",
    "In this examples, we use a proportion 50%-50%"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 90,
   "id": "f1f43892",
   "metadata": {},
   "outputs": [],
   "source": [
    "from sklearn.model_selection import train_test_split\n",
    "\n",
    "# make train and test sets\n",
    "X_train,X_test, y_train,y_test = train_test_split(X, y, \n",
    "                                                  test_size=0.50, \n",
    "                                                  random_state=492 )"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 91,
   "id": "3a9daf57",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Time taken to fit BDT: 0.3s\n",
      "AdaBoostClassifier(algorithm='SAMME',\n",
      "                   base_estimator=DecisionTreeClassifier(max_depth=2),\n",
      "                   learning_rate=0.5, n_estimators=12)\n"
     ]
    }
   ],
   "source": [
    "from sklearn.tree import DecisionTreeClassifier\n",
    "from sklearn.ensemble import AdaBoostClassifier\n",
    "\n",
    "dt = DecisionTreeClassifier(max_depth=2) # maximum depth of the tree\n",
    "bdt = AdaBoostClassifier(dt,\n",
    "                        algorithm='SAMME', # SAMME discrete boosting algorithm\n",
    "                        n_estimators=12, # max number of estimators at which boosting is terminated\n",
    "                        learning_rate=0.5) # shrinks the contribution of each classifier by learning_rate\n",
    "\n",
    "start = time.time() # time at start of BDT fit\n",
    "bdt.fit(X_train, y_train) # fit BDT to training set\n",
    "elapsed = time.time() - start # time after fitting BDT\n",
    "print(\"Time taken to fit BDT: \"+str(round(elapsed,1))+\"s\") # print total time taken to fit BDT\n",
    "print(bdt)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 92,
   "id": "9ea16507",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "              precision    recall  f1-score   support\n",
      "\n",
      "  background       0.86      0.95      0.90     10172\n",
      "      signal       0.94      0.85      0.89      9989\n",
      "\n",
      "    accuracy                           0.90     20161\n",
      "   macro avg       0.90      0.90      0.90     20161\n",
      "weighted avg       0.90      0.90      0.90     20161\n",
      "\n",
      "Area under ROC curve for test data: 0.9658\n"
     ]
    }
   ],
   "source": [
    "from sklearn.metrics import classification_report, roc_auc_score\n",
    "y_predicted = bdt.predict(X_test) # get predicted y for test set\n",
    "print (classification_report(y_test, y_predicted,\n",
    "                            target_names=[\"background\", \"signal\"]))\n",
    "print (\"Area under ROC curve for test data: %.4f\"%(roc_auc_score(y_test,\n",
    "                                                    bdt.decision_function(X_test))) )"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 93,
   "id": "02665fcf",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 432x288 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    },
    {
     "data": {
      "image/png": "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nzNgwAAmTJhAmzZtgh2WakA0CYSn2nzuYZcIouvBwPWnT59m/vz5HDp0iM6dO3P11VcHOySlVBgL/l4xgOrDOYIdO3Ywe/ZsTp48ydSpU7njjjto1qxZUGNSygkRERH079+f3r17M2XKFL799tuyaTt27GD06NFceeWVdO3ald/+9rcY891wJYsWLSI9PZ0ePXrQvXt3fvrTn1a4jQ8//JCnn37a6aLU2pkzZxg7dixdu3Zl7NixnD17tsL5XnzxRXr37k2vXr144YUXyl6//fbb6d+/P/379yctLY1hw4YBsG3bNu655546izOsEoHHa4LW11Dpl7xNmzb06NGDRx55RHsKVQ1aXFwcmzdvZvv27bRo0YJZs2YBUFhYyA033MCTTz7Jnj172LJlC6tWreLll18GYPv27Tz66KP861//YteuXWzfvp3OnTtXuI3nnnuOH/7wh37H5Ha7L79gNfDss88yZswYvvnmG8aMGcOzzz57yTzbt2/nr3/9K+vWrWPLli0sWLCAb775BoB33nmHzZs3s3nzZm655RamTJkCQJ8+fcjJyeHQoUN1EmfYNQ0FukbgdrtZtmwZubm53HbbbbRo0YJbbrkloDGo8PZ/5+9g59FzdbrOnm2b8F9Tevk9/zXXXMPWrVsBePvttxk2bBjjxo0DoHHjxvz5z38mIyODRx55hOeee45f/vKXdO/eHYDIyMgKd/bffPMNMTExJCcnAzB//nyeeeYZSkpKSEpK4q233iIlJYWnnnqKo0ePcuDAAZKTk3nxxReZOXNm2U70hRdeYNiwYaxbt44f/ehHFBYWEhcXxz/+8Q+6det2We/TRx99VDa05N13301GRga///3vL5pn165dXH311TRu3BiAkSNH8sEHH/D444+XzWOMYe7cuWRmZpa9NmXKFObMmXPRfLUVVjUCtwnsfQSHDx/mlVdeYeXKlURHR+PxeAK2baXqC4/Hw+eff84NN9wAWM1CgwYNumieLl26kJ+fz7lz59i+ffsl0yuydu1aBg4cWPb82muvZc2aNWzatIlp06bx3HPPlU3buHEjH330EW+//Tb/+Z//yf/5P/+H9evX8/7773P//VZP+N27d2f58uVs2rSJp59+ml/84heXbPP8+fNlTTXl/3bu3HnJ/CdOnCi7CKRNmzacPHnyknl69+7N8uXLyc3NpaCggIULF3L48OGL5lmxYgUpKSlcccUVZa+lp6ezYsWKat8nf2iNwAElJSV8/vnnrFu3jqZNmzJjxoyLPkClAqkmR+51qbCwkP79+3PgwAEGDRrE2LFjge/G0qhITZpKjx8/ftGl1jk5Odx+++0cO3aMkpKSi66jv+GGG4iLiwNgyZIlF+20z507x/nz58nLy+Puu+/mm2++QURwuVyXbDMxMZHNmzf7HaM/evTowRNPPMHYsWNJSEigX79+l/Qq/O9//5vp06df9FqrVq04evSS0X9rJaxqBB6vCchVQx6Ph507dzJ48GAefvhhTQIqLJWeIzh48CAlJSVl5wh69erFhg0bLpo3OzubhIQEEhMT6dWrFxs3bqx2/bGxsRfdOf3YY4/x6KOPsm3bNl555ZWLpvmO3e31elm9enVZ2/uRI0dITEzk17/+NaNGjWL79u3Mnz+/wruya1ojSElJ4dixYwAcO3aMVq1aVViWH/zgB3z11VcsX76cFi1aXNS7sNvtZt68edx+++0XLVNUVFSW3C5XWCUCJ68aKiwsJCsrC6/XS1xcHI888giTJk3SnkJV2GvatCkvvfQSzz//PC6XixkzZrBy5UqWLFkCWL+d//iP/yhr6/7Zz37G7373O/bssYYx93q9/PGPf7xkvd26dWPv3r1lz/Py8mjXrh0Ab7zxRqXxjBs3jj//+c9lz0uP8H2Xf/311ytctrRGUNFfz549L5n/hhtuKIvljTfeYOrUqRWut7TJ6NChQ8ybN++io/8lS5bQvXt3UlNTL1pmz5499O7du9Jy1kR4JQIvjvQ+unPnTmbNmsXy5cvL2va0kzilvjNgwAD69evHnDlziIuL46OPPuKZZ56hW7du9OnTh8GDB/Poo48C0LdvX1544QWmT59Ojx496N27d9lRta9hw4axadOmsivynnrqKW677TaGDx9edgK5Ii+99BIbNmygb9++9OzZk9mzrdFzH3/8cX7+858zbNiwOjuf9+STT/LZZ5/RtWtXPvvsM5588kkAjh49yqRJk8rmu+WWW+jZsydTpkxh1qxZNG/evGzanDlzLmkWAli6dCmTJ0+ukzjF99rdUJCenm7KVyv91enJj3l09BX8ZNzlXQlQ6vz58yxatIhdu3bRunVrpk6dSuvWretk3XUlKyuLjIyMYIcRUFpm60qUHj16BC+gADh//jy/+tWv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\n",
      "text/plain": [
       "<Figure size 432x288 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "# we first plot the Neural Network output\n",
    "signal_decisions = bdt.decision_function(X[y>0.5]).ravel() # get probabilities on signal\n",
    "background_decisions = bdt.decision_function(X[y<0.5]).ravel() # get decisions on background\n",
    "\n",
    "plt.hist(background_decisions, color='red', label='background', \n",
    "         histtype='step', # lineplot that's unfilled\n",
    "         density=True ) # normalize to form a probability density\n",
    "plt.hist(signal_decisions, color='blue', label='signal', \n",
    "         histtype='step', # lineplot that's unfilled\n",
    "         density=True, # normalize to form a probability density\n",
    "         linestyle='--' ) # dashed line\n",
    "plt.xlabel('BDT output') # add x-axis label\n",
    "plt.ylabel('Arbitrary units') # add y-axis label\n",
    "plt.legend() # add legend\n",
    "\n",
    "\n",
    "# we then plot the ROC\n",
    "plt.figure() # make new figure \n",
    "\n",
    "from sklearn.metrics import roc_curve, auc\n",
    "\n",
    "decisions = bdt.decision_function(X_test).ravel() # get probabilities on test set\n",
    "\n",
    "# Compute ROC curve and area under the curve\n",
    "fpr, tpr, _ = roc_curve(y_test, # actual\n",
    "                        decisions ) # predicted\n",
    "\n",
    "# Compute area under the curve for training set\n",
    "roc_auc = auc(fpr, # false positive rate \n",
    "              tpr) # true positive rate\n",
    "\n",
    "plt.plot(fpr, tpr, label='ROC (area = %0.2f)'%(roc_auc)) # plot test ROC curve\n",
    "plt.plot([0, 1], # x from 0 to 1\n",
    "         [0, 1], # y from 0 to 1\n",
    "         '--', # dashed line\n",
    "         color='grey', label='Luck')\n",
    "\n",
    "plt.xlabel('False Positive Rate') # x-axis label\n",
    "plt.ylabel('True Positive Rate') # y-axis label\n",
    "plt.title('Receiver operating characteristic (ROC) curve') # title\n",
    "plt.legend() # add legend\n",
    "plt.grid() # add grid"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.9.6"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
